<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: windows | bloated]]></title>
  <link href="http://deadc.github.com/blog/categories/windows/atom.xml" rel="self"/>
  <link href="http://deadc.github.com/"/>
  <updated>2012-10-20T19:23:45-03:00</updated>
  <id>http://deadc.github.com/</id>
  <author>
    <name><![CDATA[deadc]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby / DL: Acessando funções externas]]></title>
    <link href="http://deadc.github.com/blog/2012/10/20/ruby-slash-dl-acessando-funcoes-externas/"/>
    <updated>2012-10-20T14:49:00-03:00</updated>
    <id>http://deadc.github.com/blog/2012/10/20/ruby-slash-dl-acessando-funcoes-externas</id>
    <content type="html"><![CDATA[<p>Eu estava precisando acessar uma DLL especifica no Windows para automatizar um processo no serviço, eu (ainda!) não domino muito a linguagem ruby, mas por conta de todos meus colegas de trabalho fazerem uso, inclusive do RoR meio que fui absorvido por essa linguagem que, depois de python virou uma das minhas preferidas.</p>

<p>Pois bem, depois de algumas tentativas frustradas na sexta-feira, resolvi no sábado pesquisar melhor como em ruby, acessar funções externas de dll’s e lib’s. meu maior problema na sexta era a falta de compatibilidade de versões do ruby, eu escrevia um código pra ruby 1.9.2 e tentava rodar em uma versão anterior, 1.8.7 (Windows em produção).</p>

<p>Em casa, consegui escrever 2 scripts para versões distintas e finalmente criar o script para acessar a DLL, o script é tão simples que cheguei seriamente a pensar em não publicar isso, mas como pode ser util para alguém, segue ai!
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>dlopen18.rb  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="err">‘</span><span class="n">dl</span><span class="err">’</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;dl = DL.dlopen(‘libcurl.so’)</span>
</span><span class='line'><span class="sr">mycall = dl[&quot;curl_version&quot;,&#39;S&#39;]</span>
</span><span class='line'><span class="sr">puts mycall.call&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
E a versão para Ruby 1.9.2, que é um pouquinho diferente, mas tão facil quanto:
<div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span>dlopen19.rb  </span></figcaption>
 <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">require</span> <span class="err">‘</span><span class="n">dl</span><span class="err">’</span>
</span><span class='line'><span class="nb">require</span> <span class="err">‘</span><span class="n">fiddle</span><span class="err">’</span><span class="o">&lt;</span><span class="sr">/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="sr">&lt;p&gt;dl = DL.dlopen(‘libcurl.so’)</span>
</span><span class='line'><span class="sr">mycall = Fiddle::Function.new(dl[&#39;curl_version&#39;], [], Fiddle::TYPE_VOIDP)</span>
</span><span class='line'><span class="sr">puts mycall.call&lt;/</span><span class="nb">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nb">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
Lembrando que por conta do uso do Fiddle, este exemplo só funciona no Ruby 1.9.3 ou superior, para ser 100% compativel com 1.9 você deve fazer as modificações necessárias.</p>

<p>Explicando: no primeiro script onde se lê “curl_version” é aonde vai o nome da função externa, que a lib ou dll contém, no segundo campo, é o tipo de entrada da função mais o tipo de retorno, se a função recebesse algum argumento como por exemplo do tipo String e retornasse um Inteiro, ficaria assim:
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">mycall</span> <span class="o">=</span> <span class="n">dl</span><span class="o">[</span><span class="s2">&quot;funcao&quot;</span><span class="p">,</span><span class="s1">&#39;SI&#39;</span><span class="o">]</span>
</span><span class='line'><span class="nb">puts</span> <span class="n">mycall</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="err">“</span><span class="n">string</span><span class="err">”</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
no segundo script isso fica mais claro já que, o retorno fica no final, enquanto os argumentos dentro de um array, que neste caso está vazio já que a função não necessita de nenhum parametro. Mais referencias de como usar e sobre os tipos possiveis de entrada nas funções RTFM</p>

<p>uma dica para quem usa linux e quer saber quais funções determinada lib possui e não tem o código-fonte, é utilizar o comando nm:</p>

<pre>
deadcow@stack ~ $ nm –defined-only -D /usr/lib/libcurl.so|grep easy
00000000000297d0 T Curl_easy_addmulti
0000000000029b40 T Curl_easy_initHandleData
00000000000319c0 T Curl_multi_rmeasy
0000000000040270 T Curl_pp_easy_statemach
0000000000029e30 T curl_easy_cleanup
0000000000029c00 T curl_easy_duphandle
0000000000022de0 T curl_easy_escape
0000000000029e00 T curl_easy_getinfo
000000000002a0d0 T curl_easy_init
00000000000299b0 T curl_easy_pause
0000000000029e50 T curl_easy_perform
0000000000029930 T curl_easy_recv
0000000000029b60 T curl_easy_reset
0000000000029880 T curl_easy_send
0000000000029f40 T curl_easy_setopt
0000000000034e30 T curl_easy_strerror
0000000000022cb0 T curl_easy_unescape
deadcow@stack ~ $
</pre>


<p>obviamente consultando o oráculo depois para saber mais sobre a função!</p>
]]></content>
  </entry>
  
</feed>
